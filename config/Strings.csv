ID;EN;CN
ERROR_SIGNAL;Error: signal %1% (%2%);
MSG_FROM_UNCOVERED;msg from uncovered, subExpr kind: %1%;
INCORRECT_VALUE_FOR_ENUM;Incorrect value for the enum: [%1%];
INCORRECT_VALUE_FOR_SUPPORTED_LANGUAGES;Incorrect value for supported languages [;
GOTO_STATEMENT_BEFORE_VARIABLE_DECLARATION;Goto statement before variable declaration;
INITIAL_MEMORY_ZEROING;Initial memory zeroing;
REDUNDANT_MEMORY_ZEROING;Redundant memory zeroing;
NULL_POINTER;Null pointer;
FREED_MEMORY;Freed memory;
DOUBLE_FREE;Double free;
FREE;Free;
USE_AFTER_FREE;Use after free;
EXTERNAL_DATA;External data;
UNINITIALIZED_MEMORY;Uninitialized memory;
POSSIBLE_ZERO;Possible zero;
INITIAL_CHECK;Initial check
IS_USED_AS_FORMAT_STRING;is used as format string;
DEREFERENCE;dereference;
USAGE;usage;
IS_USED_AS_DIVIDER;is used as divider;
GREATER_BUFFER_SIZE;can be greater than destination buffer size;
BUFFER_SIZE;Buffer size;
BUFFER;buffer;
DESTINATION;destination;
THIS;this;
SIZE_IN_THE_PARAMETER;size in the parameter;
ALLOC_SOURCE;Allocated memory;
DESCRIPTOR_SOURCE;Descriptor source;
RESOURCE_SOURCE;Locking resource source;
PASSED_AS_THE;%1% passed as the %2%;
SOURCE;%1% source;
SOURCE_WITH_DESC;%1% source (%2%);
RESULT;result;
OF;%1% of %2%;
RETURNED_AS_THE;%1% returned as the %2%;
RETURNED_FROM_CALL;%1% returned from this call;
FIELD_OF_OBJECT;field of object;
ASSUME_FUNCTION_IS_EXECUTED;Function %1% is executed;
ASSUME_RETURN_HERE;Assume return here;
ASSUME_CONDITION;%1% is %2%;
UNTRUSTED_DATA;Untrusted data;
UNTRUSTED_DATA_PROPAGATION_FROM_ARG;Untrusted data propagated from the %1% to the %2%;
ANNOTATED_BY_MACRO;Annotated by macro;
ANNOTATED_BY_CONFIG;Annotated by config;
FUNCTION_ANNOTATED_BY_MACRO;Function is annotated by macro;
UNDEFINED_FUNCTION;Undefined function;
PUBLIC_FUNCTION;Public function;
EXPRESSION_EMPTY_OR_CONTAINS_ONLY_WHITE_SPACES;Expression is empty or contain only white spaces;
NODE_DESCRIPTION_MUST_START_FROM;Node description must start from '/';
STATIC_ANALYZER_OF_CPP_SOURCE_CODE;Static analyzer of C++ source code;
PATH_TO_FILE_FOLDER_OR_HCXX_FILE_TO_SCAN;path to file, folder or HCXX-file to scan;
GENERATE_ANNOTATIONS_FOR_SCOPE_FILE;generate annotations for scope file;
PATH_TO_COMPILER_EXECUTABLE;path to compiler executable;
GENERATE_CALL_GRAPH_PATHS_FOR_ENTRY_POINT;generate call graph paths for the specified entry point;
MAX_DEPTH_OF_CALL_GRAPH_PATH;max depth of the call graph path;
PATH_WHERE_REPORT_WILL_BE_STORED;Path where report will be stored;
PATH_TO_FILE_WITH_INSPECTIONS_PROFILE;Path to file with inspections profile;
ADD_ASSUMPTIONS_IN_PROBLEM_TRACE;add assumptions in problem trace;
PRINT_USAGE;Print usage;
PARAMETER_SCOPE_SHOULD_BE_PROVIDED;Parameter '--scope' should be provided;
PROFILE_FILE;Profile file ;
CAN_NOT_BE_LOADED; cannot be loaded.;
NOT_ENOUGH_COMMAND_LINE_PARAMETERS;Not enough command line parameters;
USE_HELP_TO_GET_MORE_INFORMATION;Use --help to get more information.;
MEMORY_ADDRESS;Memory address;
MEMORY_SIZE;Memory size;
MEMORY_OFFSET;Memory offset;
CONSTANT_VALUE;Constant value;
UNTRUSTED_MEMORY_SIZE;Untrusted memory size;
UNINITIALIZED_VARIABLE_DECLARATION;Uninitialized variable declaration;
UNINITIALIZED_VARIABLE_USAGE;Uninitialized variable usage;
LOCAL_ADDRESS_RETURN;Do not return address of local variable;
TEST_STRING;English text;中文文本;
REDUNDANT_HEAP_ALLOC;Redundant heap allocation. Stack variable is more preferable;
REDUNDANT_LOOP_FIXED_ALLOC;Redundant loop allocation with fixed size;
REDUNDANT_LOOP_ARG_ALLOC;Redundant loop allocation with size, not changed in loop;
VARIABLE_INITIALIZATION;Variable initialization;
REDUNDANT_VARIABLE_INITIALIZATION;Redundant variable initialization;
STACK_VARIABLE;Stack variable allocation;
STACK_VARIABLE_ATTEMPT_TO_DELETE;Attempt to deallocate memory allocated on stack;
WRONG_ALLOC_DEALLOC;Attempt to return a memory resource to the system, with call of incompatible release function.;
WRONG_LOCK_UNLOCK;Attempt to unlock resource, with call of incompatible release function.;
WRONG_DESCRIPTOR_ALLOC_FREE;Attempt to free descriptor, with call of incompatible release function.;
USED_GLOBAL_VARIABLE;Used global variable;
AccessSpecifierIndentationChecker;Indent access specifier to the same level as the class keyword.;
AccessSpecifierOrderChecker;Class access specifier declarations are ordered in the sequence: public, protected, private.;
AvoidCStyleCastChecker;If type casting is required, use the type casting provided by the C++ instead of the C style.;
CamelCaseChecker;%1%;
ConditionHasBracesChecker;Use braces to include an if statement.;
ConsistentBraceStyleChecker;Use consistent braces style (K&R or Allman).;
CycleHasBracesChecker;Use braces after loop statements.;
DestructorIsDefinedChecker;Define destructors if constructors are defined;
DoNotModifyVariableInExprChecker;Don't use incrementing or decrementing variable in the same expression.;
DoNotUseVariableArraysChecker;Do not use variable-length arrays.;
EvaluateIntExprInALargerSizeChecker;Evaluate integer expressions in a larger size before comparing or assigning to that size;
ExpressionWrapChecker;Keep a consistent line break style for expressions and ensure that operators are placed at the end of a line;
FileExtensionChecker;%1%;
FileNameAsTopLevelRecordNameChecker;Keep C++ file names the same as the class, union or struct name.;
ForbiddenFunctionsChecker;Do not use forbidden functions.;
ForbiddenTypeChecker;Do not use auto_ptr.;
SV.STR.FMT.TAINT;Format parameter is externally controllable.;
SV.STR.FMT.TAINT_DESCRIPTION;Format parameter is externally controllable.;
FuncCallParamsOneLineChecker;A function call parameter list should be placed on one line. When the parameter list exceeds the line length and requires a line break, the parameters should be properly aligned.;
FunctionLengthChecker;Number of lines in functions is no more than 50 lines.;
FunctionParametersAssertChecker;Asserts for function parameters checker implementation.;
GlobalVariablePrefixChecker;Add the prefix 'g_' to global variables;
HastBasedChecker;HAST-based checker.;
IndentChecker;Use spaces to indent and indent 4 spaces at a time;
InitFieldsInConstructorsChecker;Initialize class fields inside of constructors instead of in declarations%1%;
InitializerListWrapChecker;When an initialization list is wrapped, ensure that the line after the break is indented and aligned properly;
IntegerLiteralSuffixChecker;Do not suffix a lowercase letter "l" to a numeric constant.;
LargeStackAllocationChecker;Avoid large stack allocations in a function;
LocalVariableInitialValueChecker;Define an initial value for the local variable declaration.;
LongLineChecker;Each line of code should contain a maximum of 120 characters.;
MacroLengthChecker;Function-like macros should be short.;
MacroNameChecker;Macro names should not be the same as keywords.;
MembersNamingChecker;Use the same style for fields naming(lowerCamelCase or lowerCamelCase with prefix m_'/'_'/'my'). Do not add prefixes to public fields.;
MemoryOperationsFunctionsChecker;Do not use dangerous functions related to memory operations.;
UninitializedMemoryUsageChecker;The variable '%1%' is an uninitialized value.;
MultiConditionsInAssertChecker;Do not place multiple condition statements in the same assert function.;
MultipleAssigmentsPerLineChecker;Multiple assignment statements cannot be written on one line;
MultipleVarDeclPerLineChecker;Multiple variable definitions cannot be written on one line;
NestedBlocksChecker;Number of nested code block depth no more than 4.;
NullPtrDereferenceChecker;Null dereference;
UnusedParamChecker;Parameter '%1%' is not used in function;
ParameterNumberChecker;Number of parameters in function no more than %1% parameters.;
PointerAndReferenceCodestyleChecker;The pointer\reference type *\& follows a variable name or type. There can be only one space to the side of it.;
PointerConvertToIntChecker;Do not convert between integer and pointer;
PointerLogicalOperatorChecker;Do not perform logical or bit operations on pointers.;
PreprocessorDirectiveIndentChecker;The number sign (#) that starts a preprocessor directive must be at the beginning of the line and can be indented in nested preprocessor directives;
PtrArgIsCheckedChecker;Check whether the string or pointer is NULL when it is used as a function parameter;
RetTypeAndFuncNameOnTheSameLineChecker;The return type and the function name of a function declaration or definition must be on the same line;
ReturnMemberAddressChecker;Add the const type if the public interface of a class returns the private data address of the class.;
SeparateLinesInConditionalStatementChecker;Each branch in conditional statement should be placed on separate lines.;
SizeOfPointerChecker;Do not perform the sizeof operation on pointer variables.;
SwitchDefaultChecker;Switch statement shall have a default label.;
SwitchIndentationChecker;Indent case and default labels in a switch statement with four spaces. Further indent label contents by four spaces from the label.;
TabIndentChecker;Use spaces to indent;
SignedIntBitwiseOperatorChecker;Do not use bitwise operators in signed integers.;
UseAfterFreeChecker;%1%;
DivisionByZeroChecker;Division by zero;
SimpleChecker;%1%;
UncoveredEmptyChecker;Paren expression found;
BufferMaxSizeChecker;Size of the %1% can be less than %2%;
DoNotReturnAddrOfLocalVarChecker;Do not return the address of a local variable to outside of its scope.;
GenericTaintChecker;Generic taint checker;
MyChecker;This parameter is externally controllable.;
OutOfBoundsChecker;Out of memory bounds access;
MismatchedMemManagementChecker;%1%;
RedundantZeroMemoryChecker;Redundant zeroing of memory;
RedundantHeapAllocChecker;%1%;
RedundantMultipleIfElseChecker;Use switch instead of multiple if-then-else statements;
RedundantVolatileGlobalVarChecker;Do not use volatile to decorate global variables;
PlatformSpecificLoopVarChecker;Loop control variable "%1%" can be extended to size of platform's architecture.;
DoNotUseMemsetOnBasicTypesChecker;Use assignment instead of %1% for basic types.;
RedundantLoopCondCalcChecker;Avoid redundant calculations in loop condition.;
UnusedMemberExpressionChecker;Unused data structure member.;
UnusedVariablesChecker;There is no any "read" operations with that variable.;
GlobalVariableUsageChecker;Do not use global variables inside functions directly, assign them to local variables;
AlignmentChecker;Preferentially use the %1%-bit alignment mode when defining data structures.;
ExceptionsUsageChecker;Usage of C++ exceptions is not allowed.;
PFM.RULE.CPP.01_DESCRIPTION;PFM.RULE.CPP.01 In the C++ language development project, the exception handling mechanism of the try catch needs to be disabled from the compiler level to avoid the overhead caused by this. In practice, if gcc compiler is used, -fno-exceptions can be used to close the exception mechanism.;
PostfixUsageChecker;Use prefix instead postfix for containers;
PFM.RULE.CPP.11_DESCRIPTION;PFM.RULE.CPP.11 For the duration of containers such as STL, it is recommended that the pre-positioned auto-increase (self-decrement) operation of the iterator be used instead of the post-positioned auto-increase (self-decrement) operation, because the pre-positioned operation does not need to generate local temporary variables and has higher performance. The post-position function must create a local temporary object as a return value. The implementation code above creates an explicit temporary object (oldValue), which must be constructed and then deconstructed. The preposition function has no such temporary object, and its performance is higher.;
RedundantVectorUsageChecker;Usage of std::array is preferable instead of std::vector with constant size.;
PFM.RULE.CPP.13_DESCRIPTION;PFM.RULE.CPP.13 std::array is designed to provide similar functions and performance to native arrays. If the number of elements is determined and the data volume is not large, you are advised to use std::array instead of std::vector.;
UnlikelyInstructionsSeparatedChecker;Move large number of instructions on unlikely path to function;
RedundantInitializationChecker;Redundant struct or array initialization;
MemoryAndResourceLeakChecker;%1%;
MEM_LEAK;Missing release of memory after effective lifetime;
DESCRIPTOR_LEAK;Missing release of descriptor after effective lifetime;
RESOURCE_LEAK;Missing resource unlock;
DoubleCheckChecker;Redundant check, the variable is already checked;
EmbeddedCyclesOrderChecker;Performance may be improved by changing order of Indexes. Index #%1% violite correct order.;
UsingFloatingPointTypeChecker;Use integer instead floating point types in calculations;
PossibleInlineFunctionChecker;The inline function or macro function is preferred.;
IS_NOT_PRESENTED; is not presented in profile file.;
RETURN_OF_CONST;The constant value is returned;
ReturnConstantValueChecker;Do not return constant value in function.;
ZeroEntireStringArrayChecker;Avoid zeroing the entire C-style string array. Use null terminator;
PFM.RULE.DS.01_DESCRIPTION;PFM.RULE.DS.01 When defining data structures, four-byte alignment is adopted to improve data access efficiency. Note that if the message data structure is defined across CPUs, subsystems, and modules, the 4-byte alignment mode is preferred on the basis of complying with the interface contract.;PFM.RULE.DS.01 定义数据结构时，优先采用四字节对齐的方式 【级别】 建议 【分类】 提升访存效率 【说明】 定义数据结构时，采用四字节对齐的方式，可以提高数据访问的效率 - 需要注意的是，如果是跨CPU/子系统/模块的消息数据结构定义，在遵从接口契约的基础上，优先采用四字节对齐的方式定义 - 【原理】 以32位系统为例，CPU在处理数据读写操作时，会以四字节起始地址读取，此时如果目标数据跨越了自然对齐边界，则会导致CPU从一次读取变为分两次读取后再拼接，导致代码的指令cycle数抬升 - 另外，按照四字节对齐的方式定义数据结构，还可以避免字节不对齐导致的CPU处理异常等问题;
PFM.RULE.VAR.02_DESCRIPTION;PFM.RULE.VAR.02 It is recommend to use “=” to do assignment operation to basic data type (like U8/U16/U32/U64). Memory operation like (memset, memcpy) is not recommended. Thus to avoid function stack operation performance decrease.;PFM.RULE.VAR.02 基础数据类型直接赋值 【级别】 要求 【分类】 降低指令数 【说明】 对于基础数据类型（如U8/U16/U32/U64等），建议直接赋值 - 不推荐使用内存操作函数(memset、 memcpy等)，避免函数栈操作的性能损耗 - 【原理】 调用内存操作参数进行赋值，系统需要入栈压栈的操作，而直接赋值时不会有此类操作，能够降低编译生成的机器指令数;
PFM.RULE.FUNCDESIGN.04_DESCRIPTION;PFM.RULE.FUNCDESIGN.04 Avoid using repeatable checks of the same expression if expression members has not changed on execution path between sequential checks. It's recommended to get rid of redundant checks by removing the sequential check or by redesigning the code.;
PFM.RULE.CTRLSTATEMENT.05_DESCRIPTION;PFM.RULE.CTRLSTATEMENT.05 Generally, the address offset of the low dimension of a two-dimensional array is small. If the address offset is used as the inner layer of the loop, the cache utilization can be improved. For for loops, more inner loops result in fewer expanded statements.;PFM.RULE.CTRLSTATEMENT.05 多重循环，地址偏移小且次数多的循环放到内层 【级别】 要求 【分类】 提升访存效率 【说明】 一般来说二维数组，其低维的地址偏移小，如果以此为循环内层，可以提升缓存的利用率。对于for循环，内层循环更多，则展开的语句执行的次数更少。;
PFM.RULE.VAR.01_DESCRIPTION;PFM.RULE.VAR.01 Assume there is no multiple-threads accessing the same variable, when a global variable is used more than twice in program, it is recommended to use local variable to store the global variable value. Compiler will not do any optimization job.;PFM.RULE.VAR.01 全局变量使用局部变量预取 【级别】 建议 【分类】 提升指令效率 【说明】 不存在多线程访问的前提下，两次或以上使用某一个全局变量时，通过使用局部变量预取提升访问数据的局部性;
PFM.RULE.FUNCDESIGN.01_DESCRIPTION;PFM.RULE.FUNCDESIGN.01 During actual development, the number of transferred parameters can be reduced for functions in the performance hotspot process. Note that the parameter transfer modes vary with CPU instruction systems/compilers. Therefore, the upper limit of the input parameters of the performance hotspot function needs to be set separately according to different instruction systems.;PFM.RULE.FUNCDESIGN.01 避免冗余参数传递，建议性能敏感代码的函数入参不超过4个 【级别】 建议 【分类】 降低指令数 【说明】 实际开发过程中，对于性能热点流程中的函数，可以考虑精简传递参数的个数，需要注意的是，针对不同CPU指令体系/编译器，参数传递的方式都会存在差异，因此性能热点函数的入参数量上限需要根据不同的指令体系单独设置； 【原理】 在函数执行过程中，其实参传递有两种不同的方式：当函数参数较少(不同CPU体系下可能存在差异)时，一般会通过寄存器直接进行实参传递；当函数参数数量超过一定个数后，多出来的参数会通过压栈的方式将实参传递到函数，其中，相对于前者来说，压栈/出栈的方式传递参数会带来更大的性能开销;
PFM.RULE.CTRLSTATEMENT.03_DESCRIPTION;PFM.RULE.CTRLSTATEMENT.03 Using of platform specific basic types as loop control will improve performance.;PFM.RULE.CTRLSTATEMENT.03 循环变量使用和体系结构匹配的整数类型 【级别】 要求 【分类】 提升指令效率 【说明】 以32位处理器为例，对于U8或者U16，部分编译器会进行与操作或者前置归零来将值扩展成32位，增加了不必要的指令开销。;
PFM.RULE.FUNCDESIGN.03_DESCRIPTION;PFM.RULE.FUNCDESIGN.03 It's recommended to define functions with a small body (for example, within 3LOC) and a large number of calls as inline. The function invoking process has overheads such as stack entry and stack exit. If the called function is far away from the current function, it may not be loaded to the I-Cache. In this case, there is overhead of loading instructions.;
PFM.RULE.STATEMENT.03_DESCRIPTION;PFM.RULE.STATEMENT.03 Multiple dereference of address, can produce redundant asm instruction. This kind of optimization can be done by GCC with option -O automatically.;PFM.RULE.STATEMENT.03 复杂结构体地址预取 【级别】 要求 【分类】 降低指令数 【说明】 两次或以上使用某一多重结构内部成员时，建议转化为临时指针进行操作，通过使用本地临时指针替换复杂数据结构，减少重复的偏移地址计算 - 这种优化， 一般用GCC的-O选项就可以实现。;
RedundantAddressCalculationChecker;Avoid redundant address calculations.;
ADDRESS_CALC;Address calculation;
PFM.RULE.MEM.03_DESCRIPTION;PFM.RULE.MEM.03 Frequent memory application and release will not only reduce the efficiency but also cause memory fragmentation. For certain memory usage, it is recommended that you apply for memory once and use it repeatedly. If function is working with variables that are only required until the function using them is alive. Then the function need to use the stack, which is faster and easier than allocation on heap.;
PFM.RULE.STATEMENT.01_DESCRIPTION;PFM.RULE.STATEMENT.01 Variables initialization work should be correct and unnecessary. Avoiding duplicates initialization will improve performance.;PFM.RULE.STATEMENT.01 避免冗余初始化 【级别】 建议 【分类】 降低指令数 【说明】 对变量或内存块进行正确、必要的初始化，避免冗余初始化，带来的性能风险;
PFM.RULE.STATEMENT.04_DESCRIPTION;PFM.RULE.STATEMENT.04 Recalculation of condition value on each iteration of cycle could reduce performance of application. It's recommended to store nonchanged expression to local variable.;PFM.RULE.STATEMENT.04 减少或者避免重复计算 【级别】 要求 【分类】 降低指令数 【说明】 减少重复的遍历、运算等，使用变量保存公共的运算结果，将结果进行传递等，提高效率。;
PFM.RULE.CTRLSTATEMENT.02_DESCRIPTION;PFM.RULE.CTRLSTATEMENT.02 It is recommended to use switch/case to reduce unnecessary if-statements.;PFM.RULE.CTRLSTATEMENT.02 使用switch语句替代if语句的重复判断 【级别】 要求 【分类】 降低指令数量 【说明】 使用Switch/case语句，减少不必要的if语句的多次条件判断。 【原理】 由于switch...case会生成一个跳转表来指示实际的case分支的地址，跳转表的索引号等于switch变量的值，因此switch...case不用像if...else if那样遍历条件分支直到命中条件，从而提升执行效率。;
PFM.RULE.VAR.03_DESCRIPTION;PFM.RULE.VAR.03 The declaration of a variable as volatile tells the compiler that the variable can be modified at any time externally to the implementation. This ensures that the compiler does not optimize any use of the variable on the assumption that this variable is unused or unmodified.;PFM.RULE.VAR.03 慎用volatile修饰全局变量 【级别】 建议 【分类】 减少执行阻塞 【说明】 全局变量尽量不使用volatile修饰 ，以便编译器优化汇编代码提高性能。 【原理】 volatile关键字用来提醒编译器它后面所定义的变量随时有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。volatile的本意是为了避免编译器优化时将变量先读取到寄存器，而后直接从寄存器取值，而忽略了其他线程更改此变量时的场景。解释为 “直接存取原始内存地址”更合适。 需要注意的是，如果是多线程访问的全局变量，除非变量的值不会被其他线程改变，否则还是要使用volatile修饰。;
PFM.RULE.STATEMENT.02_DESCRIPTION;PFM.RULE.STATEMENT.02 The memory operation functions memset/memset_s involve system calls and have relatively high overheads. The larger the operation data, the higher the overheads. Therefore, for large-sized memory, the use of memset should be reduced to improve the processing efficiency.;PFM.RULE.STATEMENT.02 减少memset的调用 【级别】 建议 【分类】 降低指令数 【说明】 内存操作函数memset/memset_s涉及到系统调用，开销相对较大，操作数据越大，开销也越大，因此对于大片内存，为了提高处理效率，应该减少memset的使用。容易忽视的是，超过一定大小的结构体局部变量使用“= {0}”的方式进行初始化时，编译器也会隐式的调用memset，因此也应该尽量减少使用。 建议处理方式： 可以通过设置标志位，清除标志位来实现相同的效果。注意：需要确保对数据访问前判断标志位，避免访问无效数据。;
PFM.RULE.FUNCUSE.01_DESCRIPTION;PFM.RULE.FUNCUSE.01 When the determinative return value is set, the caller needs to make an expected judgment on the return value, which increases the performance overhead and also impacts the instruction cache.;
PFM.RULE.MEM.01_DESCRIPTION;PFM.RULE.MEM.01 Frequently used instructions are spatially organized to reduce the probability of I-CacheMiss. It's recommended to define functions with a small body (for example, within 6LOC) instead large number of instruction on unlikely path.;
PFM.RULE.STATEMENT.05_DESCRIPTION;PFM.RULE.STATEMENT.05 Constant converting of integer to double in cycle could reduce performance of your application.;PFM.RULE.STATEMENT.05 关键路径尽量用整数运算代替浮点运算 【级别】 要求 【分类】 提升指令效率 【说明】 浮点运算比整数运算消耗CPU多几倍。关键路径上，在精度允许的情况下，可通过放大一定的倍数，采用整数计算替代浮点数计算。;
PFM.RULE.STR.01_DESCRIPTION;PFM.RULE.STR.01 To set the string array to an empty string, you only need to assign the null terminator to the first byte. It will avoid zeroing the entire space, effectively reduce the number of operation instructions and improve the efficiency.;PFM.RULE.STR.01 避免对整个字符串数组清零 【级别】 建议 【分类】 降低指令数 【说明】 设置字符串数组为空字符串，只需要对第一个字节赋值'\0'，避免对整个空间清零 【原理】 有效降低操作指令数，提升效率;
MEM.BUF.SIZE.OVERFLOW_DESCRIPTION;If the program copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, it will leading to undefined behavior.;函数里，尝试把一个缓冲区的数据拷贝到另一个缓冲区之前，要对缓冲区的大小做一个验证。确保数据写入区的数据大小比数据读取缓冲区要大，这样可以避免未定义行为。;
MEM.BUF.SIZE.UNTRUSTED;Memory size of %1% (equal to %2% bytes) can be less than %3% (equal to %4%). This may lead to a buffer overflow;
MEM.BUF.SIZE.OVERFLOW_ENDING; parameter, this may lead to undefined behavior;
CHAR.BUF.SIZE.OVERFLOW_DESCRIPTION;If the program copies an input char buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, it will leading to a buffer overflow or rewriting the null-terminator;
CHAR.BUF.SIZE.OVERFLOW_ENDING; or the null terminator not being written;
G.INT.03_DESCRIPTION;Integer division by zero usually result in the failure of the process or an exception. It can also result in success of the operation, but gives an erroneous answer or lead to undefined behavior.;整数除法里被除数为零会触发很多错误。所以要确定被除数不会为零。 ;
G.VAR.06_DESCRIPTION;Because local variables are allocated on the stack, when a program returns a pointer to a local variable, it is returning a stack address. A subsequent function call is likely to re-use this same stack address, thereby overwriting the value of the pointer, which no longer corresponds to the same variable since a function's stack frame is invalidated when it returns. Therefore the value of the pointer will change unexpectedly, and it can cause the program to crash the next time the pointer is dereferenced.;局部变量是在栈上分配，当一个函数返回一个指向局部变量的指针的时候。实际该函数返回的是一个栈上的地址。当函数退出，栈也被收回，栈上的地址会被复用。当下一次调用的时候，该运行栈会被重用，同样的栈地址会被用于覆盖指针的结果。这样会导致数据不一致的错误。 ;
G.VAR.08_DESCRIPTION;The software does not sufficiently track and release allocated memory after it has been used, which slowly consumes remaining memory.;程序的内存申请与释放不匹配，会导致内存的泄漏。 ;
MEM.FUNC.MISMATCH_DESCRIPTION;When the memory management functions are mismatched, the consequences may be as severe as code execution, memory corruption, or program crash. Consequences and ease of exploit will vary depending on the implementation of the routines and the object being managed.;内存的管理函数的申请函数与释放函数的操作应该一一对应。如果用了错误的释放函数去释放申请来的内存，可能会导致程序崩溃。 ;
LOCK.FUNC.MISMATCH_DESCRIPTION;When the resource locking functions are mismatched, the consequences may be as severe as code execution, dead lock, or program crash.;
ALLOC.DESCRIPTOR.MISMATCH_DESCRIPTION;When the alloc and free descriptor functions are mismatched, the consequences may be as severe as code execution, dead lock, or program crash.;
NULL.DEREF_DESCRIPTION;Null-pointer dereferences usually result in the failure of the process. These issues typically occur due to inappropriate pointer creating, usage in multiple threads, addressing fields of a structure pointer which points to null and so on.;空指针通常会导致程序失败。导致空指针的原因包括不争取的指针创建以及使用，线程间共享等原因也会导致空指针的产生。;
NULL.UNTRUSTED.DEREF_DESCRIPTION;Null-pointer dereferences usually result in the failure of the process. These issues typically occur due to inappropriate pointer creating, usage in multiple threads, addressing fields of a structure pointer which points to null and so on.;空指针通常会导致程序失败。导致空指针的原因包括不争取的指针创建以及使用，线程间共享等原因也会导致空指针的产生。;
G.ARR.01_DESCRIPTION;The software performs operations on a memory buffer, but it can read from or write to a memory location that is outside of the intended boundary of the buffer. Languages like C and C++ allow direct addressing of memory locations and do not automatically ensure that these locations are valid for the memory buffer that is being referenced. As a result, an attacker may be able to execute arbitrary code, alter the intended control flow, read sensitive information, or cause the system to crash.;程序的读写操作必须被限制在合理的buffer里。当读写的范围超过了buffer的限制将会导致安全问题。 C语言由于独特的地址操作，允许读取buffer以外的内容，这个特性会被攻击者利用，读取内存其它位置的内容。 ;
G.VAR.01_DESCRIPTION;When reusing a resource such as memory or a program variable, the original contents of that resource may not be cleared before it is sent to an untrusted party. The uninitialized resource may contain values that cause program flow to change in ways that the programmer did not intend.;在使用一个变量或者一段之前，需要将这一段内存进行初始化。 没有初始化过的内存可能包含随机的信息，从而发生错误。 ;
G.MEM.05_DESCRIPTION;Memory reference issues can prove to be critical problems. Using previously freed memory can result in corruption of valid data or execution of arbitrary code, depending on the specific situation. When memory is freed, its contents can remain intact and accessible if it isn't reallocated or recycled. The data at the freed location may seem to be valid, but it can change unexpectedly, and cause unintended code behavior.;内存问题通常都比较严重。 使用之前被释放过的内存可能会导致意想不到的错误。;
UnusedMemberExpressionChecker_DESCRIPTION;Remove class/struct members that are not used in expressions.;内存问题通常都比较严重。 使用之前被释放过的内存可能会导致意想不到的错误。;
UnusedParamChecker_DESCRIPTION;Remove parameters that are declared in function but don't used in expressions.;把定义但是从没有被使用过的参数全文搜索出来。;
UnusedVariablesChecker_DESCRIPTION;Remove variables that are declared in function scope but don't used in expressions.;把定义但是从没有被使用过的变量全文搜索出来。;
RedundantArgCopyChecker;Argument is passed by value. Redundant copying of object.;
PFM.RULE.FUNCDESIGN.02_DESCRIPTION;PFM.RULE.FUNCDESIGN.02 In the program execution phase, select a proper parameter transfer mode based on the actual situation, and avoid parameter transfer in the value transfer mode. In the actual encoding process, pointer transfer can be used instead of value transfer. (In C++, reference transfer can be used instead of value transfer.) For parameter transfer of read-only type, the const keyword can be used to modify the input parameters.;
RedundantCacheAccessChecker;Group arrays with the same size in one array of structures with fields, corresponding to arrays;
RedundantValueCopyChecker;Redundant copy of value, use function analogue with move-semantic;
RVALUE_ANALOGUE;Overloaded function with rvalue args;
REDUNDANT_COPY_CONST_CALL;Redundant call of copy-constructor;
IMPLICIT_RVALUE_ANALOGUE;Object has implicit overloaded function with move semantic;
PFM.RULE.CPP.12_DESCRIPTION;PFM.RULE.CPP.12 Complex data structures such as STL have deep dependence on resources such as dynamic memory (or memory pool) in their implementation mechanism. In practice, when complex data structures such as STL are involved, move semantics can be used as required to reduce the overhead of copying the dynamic memory data bound to them.;
SAME_SIZE_ARRAY;Array with the same size, which used in cycle;
LOOP_WITH_SAME_SIZE_ARRAY;Loop where arrays with the same size were used;
PFM.RULE.DS.02_DESCRIPTION;PFM.RULE.DS.02 If in the data structure, a data field that is frequently accessed is defined before, and a data field that is seldom accessed is defined after most accesses need to be processed only once by loading the Cache, otherwise, multiple times of loading are required. Need to define proxy data structure to avoid frequent loading of Cache.;
ElementPlacementChecker;Use %1% instead of %2%;
PFM.RULE.CPP.10_DESCRIPTION;PFM.RULE.CPP.10 The emplace method is a new member method after C++11 and can replace the traditional insert and push_back methods. These functions can construct an object directly in the container's memory space.
UnusedField_DESCRIPTION;Checker detects class/struct members that are not used in expressions.
UnusedVariables_DESCRIPTION;Checker detects variables that are declared in function scope but don't used in expressions.
UnusedParam_DESCRIPTION;Checker detects parameters that are declared in function parameters but don't used in the function.
CSS_3.12.1_DESCRIPTION;The pointer type * follows a variable name or type. There can be only one space to the side of it.
CSS_3.12.2_DESCRIPTION;The reference type & follows a variable name or type. There can be only one space to the side of it.
RedundantAllocInCtorChecker;Move allocation from constructor to init method because it's unused in the most cases.;
PFM.RULE.CPP.08_DESCRIPTION;PFM.RULE.CPP.08 The constructor function of the class should complete only the basic construction work that the object can work. In this way, the object construction efficiency can be improved and the probability of the constructor execution error can be reduced. For example, some unnecessary memory allocation and variable initialization operations can be performed before use, rather than being all cramed into the constructor function.;
ContainerSpecificationChecker;Container specifications can be estimated and should be reserved before data inserting;
MEMORY_REALLOCATION;Reallocation of memory may be produced;
LOOP_LIMITED_BOUNDARY;Loop has limited boundary;
CONTAINER_DECLARATION;Extending container declaration;
PFM.RULE.CPP.09_DESCRIPTION;PFM.RULE.CPP.09 The memory of sequential containers with contiguous memory is automatically managed and expanded on demand. During memory expansion, a large number of time-consuming operations are performed, such as memory application/release and data copy. Therefore, if the specifications of the container can be known in advance, it should be set to avoid frequent expansion.;
VariadicFunctionUsageChecker;It's not recommended to use variadic functions.
PFM.RULE.FUNCDESIGN.05_DESCRIPTION;PFM.RULE.FUNCDESIGN.05 In the C/C++ language, functions with variable long parameter lists are supported. However, functions of other types, except for special functions such as log printing, should not adopt this flexible definition mode. For variable-length parameter lists, variable-length parameter parsing needs to be performed on the program stack in the va_start/va_arg/va_end mode. Compared with fixed-length parameter lists, parameter parsing overheads are increased. Invoking functions with variable length parameters in performance-sensitive processes may cause performance deterioration.
VariableScopeChecker;Variable %1% is used only in range %2% - %3%;
PFM.RULE.CPP.04_DESCRIPTION;PFM.RULE.CPP.04 Check variable usage scope and keep it as tiny as possible.;
RttiChecker;It is recomennded to turn off rtti. Add -fno-rtti compile option;
PFM.RULE.CPP.02_DESCRIPTION;PFM.RULE.CPP.02 RTTI should be switched off;
PossibleCyclesMergingChecker;Cycles with the same index and range may be merged.;
COMMON_CYCLE;Cycle with the same index, range and involved variables;
PFM.RULE.CTRLSTATEMENT.07_DESCRIPTION;PFM.RULE.CTRLSTATEMENT.07 Merging of common cycles can improve performance by reduce of repeated traversal and storage access operations.;
MemoryAllocationSizeChecker;Allocation size is got from untrusted source.;
MEM.ALLOC.SIZE_DESCRIPTION;Allocation size is got from untrusted source.;
UNTRUSTED_ALLOCATED_SIZE;Untrusted allocated size source;
StringSizeChecker;Possible insufficient buffer size to store output string.;
STR.SIZE_DESCRIPTION;Possible insufficient buffer size to store output string.;
MEMORY_BUFFER;Memory buffer;
SharedPointerChecker;If the exclusive ownership is specified, it is recommended that unique_ptr be used instead of shared_ptr.;
PFM.RULE.CPP.06_DESCRIPTION;PFM.RULE.CPP.06 If the exclusive ownership is specified, it is recommended that unique_ptr be used instead of shared_ptr.;
WeighingConditionChecker;%1%;
PFM.RULE.EXPRESSION.01_DESCRIPTION;PFM.RULE.EXPRESSION.01 For logical operators AND, OR the left operand is evaluated first. If it is evaluated as false for AND operator or as true for OR operator then the right operand is not evaluated. So it is better to put less expensive operand on the left side of logical AND, OR operations and more expensive operand like function call to the right.;
DeclareNearUsageChecker;It is a good programming practice to define a variable near the code block that uses it from the perspective of code performance improvement or readability.;
PFM.RULE.CPP.05_DESCRIPTION;PFM.RULE.CPP.05 It is a good programming practice to define a variable near the code block that uses it from the perspective of code performance improvement or readability.;
DocStringChecker;Classes and function declarations should be documented.;
DocString;Classes and function declarations should be documented.;
TAINT.STRING.CLI;Possible CLI injection vulnerability.;
G.FUU.16_DESCRIPTION;Do not use external controllable data as parameters for process startup functions.;
OperatorStyleChecker;This operator should be spelled as "%1%" instead of "%2%".;
LoopLimitTaintChecker;Unrestricted unstructed data can go to loop limit condition.;
LOOP.LIMIT.TAINT_DESCRIPTION;Unrestricted unstructed data can go to loop limit condition.;
BOO.TYPESIZE.MISMATCH;Found access by wrong offset;
BOO.TYPESIZE.MISMATCH_DESCRIPTION;Found access by wrong offset;
FmtSpecMismatchChecker;%1%;
FmtSpecMismatchChecker_TOO_MANY_ARGUMENTS;Too many arguments for format string;
FmtSpecMismatchChecker_TOO_FEW_ARGUMENTS;Not enough arguments for format string;
FmtSpecMismatchChecker_INVALID_SPECIFIER;Invalid format specifier "%1%";
FmtSpecMismatchChecker_EXPECTED_POINTER_TYPE;Expected pointer argument for format specifier "%1%";
FmtSpecMismatchChecker_EXPECTED_NON_POINTER_TYPE;Expected non-pointer argument for format specifier "%1%";
FmtSpecMismatchChecker_EXPECTED_MUTABLE_POINTER;Expected mutable pointer argument for format specifier "%1%";
FmtSpecMismatchChecker_EXPECTED_FLOAT;Expected floating point argument for format specifier "%1%";
FmtSpecMismatchChecker_EXPECTED_SIGNED;Expected %4%signed integer %3%argument for format specifier "%1%";
FmtSpecMismatchChecker_EXPECTED_UNSIGNED;Expected %4%unsigned integer %3%argument for format specifier "%1%";
FmtSpecMismatchChecker_EXPECTED_SIZE_EXACTLY;Expected argument size of exactly %2% bytes for format specifier "%1%";
FmtSpecMismatchChecker_EXPECTED_SIZE_AT_MOST;Expected %3%argument size of at most %2% bytes for format specifier "%1%";
FmtSpecMismatchChecker_EXPECTED_VOID_PP;Expected void** for format specifier "%1%";
FMT.SPEC.MISMATCH_DESCRIPTION;Provide a matching list of arguments for printf-style format strings;
FMT.SPEC.TMA_DESCRIPTION;Too many arguments provided for printf-style format string;
FMT.SPEC.TFA_DESCRIPTION;Not enough arguments provided for printf-style format string;
FMT.SPEC.PTR_DESCRIPTION;Pointer-related mismatch between printf-style format specifier and argument;
FMT.SPEC.SIGN_DESCRIPTION;Integer sign-related mismatch between printf-style format specifier and argument;
IntegerOverflowChecker;Possible integer overflow or wraparound.;
WrongStringIncrementChecker;Possible overflow of char array;
STRING.OVERFLOW_DESCRIPTION;Possible overflow of char array;
FIRST_INC;First unchecked increment of pointer to char array;
INT.OVERFLOW_DESCRIPTION;Integer overflow or wraparound can lead to security issue when the result is used to control looping, make a security decision, or determine the offset or size in behaviors such as memory allocation, copying, concatenation, etc;
IncompatiblePointerTypeChecker;Incompatible cast of pointer %1% may cause out-of-bounds memory access;
INCOMPATIBLE.PTR_DESCRIPTION;Incompatible cast of pointer may cause out-of-bounds memory access;
UNEXPECTED_POSITIONAL_ARGUMENT_IGNORED;Unexpected positional argument ignored;
SUGGESTION;Suggestion;
LONG_DASH_SUGGESTION;this argument appears to start with a long dash. If you meant to type a keyword argument beginning with '--', try manually re-typing the command.;
SCOPE_DOES_NOT_EXIST;Path provided by --scope does not exist;
REVERSE_NULL_DESC;Null-checking "%1%" suggests that it may be null, but it has already been dereferenced;
FORWARD_NULL_DESC;Null-checking "%1%" implies that it may be null;
BOUNDARY_CONDITION_DESC;Condition implies that the operand can be up to %1%;
STRING_LENGTH_DESC;String size equal to %1%;
ACCESS_SOURCE_DESC;equal to %1%;
INDEX_BOUNDS;%1% array "%2%" of %3% elements by accessing it with index "%4%" equal to %5%;
SENSITIVE_ANNOTATED_BY_CONFIG;Sensitive data source, function annotated by config;
SENSITIVE_ANNOTATED_RECORD;Sensitive data source, record declaration annotated by macro;
SENSITIVE_ANNOTATED_BY_MACRO;Sensitive data source, annotated by macro;
